# -*- makefile -*-

# Makefile for building a Moses system from a word-aligned corpus
# (c) 2011 - 2012 Ulrich Germann

# by default, we use good-turing smoothing for phrase tables
# (is that actually worth it?)

word-alignment ?= fast
pll.txt1 ?= ${WDIR}/crp/trn/aln/${word-alignment}/${L1}.txt.gz
pll.txt2 ?= ${WDIR}/crp/trn/aln/${word-alignment}/${L2}.txt.gz
pll.aln  ?= ${WDIR}/crp/trn/aln/${word-alignment}/${L1}-${L2}.symal.gz

define create_word_lexica

M4M_HISTORY += $1/${L1}-given-${L2}.lex.gz 

# reminder: $2,$3,$4 = L1text, L2text, alignment
$1/${L2}-given-${L1}.lex.gz: | $1/${L1}-given-${L2}.lex.gz 
$1/${L1}-given-${L2}.lex.gz: | $(if $2,$2,$$(pll.txt1))
$1/${L1}-given-${L2}.lex.gz: | $(if $3,$3,$$(pll.txt2))
$1/${L1}-given-${L2}.lex.gz: | $(if $4,$4,$$(pll.aln))
	$$(lock)
	$(moses.make-lex) \
	$(if $2,$2,$$(pll.txt1)) \
	$(if $3,$3,$$(pll.txt2)) \
	$(if $4,$4,$$(pll.aln))	 \
	$1/${L1}-given-${L2}.lex.gz \
	$1/${L2}-given-${L1}.lex.gz 
	$$(unlock)

endef

#################################################################################
# create_phrase_table: add rules to create a standard phrase table
# ADD RULES TO CREATE A STANDARD PHRASE TABLE FROM 
# $(pll.txt1),$(pll.txt2),$(pll.aln) that are specified as target-specific
# variables like this:
# $1.txt.gz: pll.txt1 = ...
# $1.txt.gz: pll.txt2 = ...
# $1.txt.gz: pll.aln  = ...
# This function is normally called indirectly via $(eval $(call add_bin_pt,...))
#
# Note: this section should be improved:
# - split into shards 
# - create bash file with jobs
# - run batch file in parallel 
#--------------------------------------------------------------------------------
define create_phrase_table

shardsdir := $(if $${phrase_extract.tmpdir},$${phrase_extract.tmpdir},$1.shards)
$(if $(filter $(if ${phrase_extract.tmpdir},${phrase_extract.tmpdir},$1.shards)/extract.done,\
${M4M_HISTORY}),,$(call extract_phrases,$${shardsdir},$${pll.txt1},$${pll.txt2},$${pll.aln}))

wlexdir := $(patsubst %/,%,$(dir $1))
$(if $(filter $(dir $1)${L1}-given-${L2}.lex.gz,${M4M_HISTORY}),\
,$(call create_word_lexica,$${wlexdir},$${pll.txt1},$${pll.txt2},$${pll.aln}))

M4M_HISTORY += $1.txt.gz

$1.txt.gz: smooth = $$(ptable.smoothing)
$1.txt.gz: | ${merge-sorted}
$1.txt.gz: | ${MOSES_BIN}/consolidate
$1.txt.gz: | $1.tmp/fwd.scored.gz
$1.txt.gz: | $1.tmp/bwd/scoring.done
	$$(info PTABLE SMOOTHING: $$(ptable.smoothing) for system $${SYSTEM} ($$@))
	$$(lock)
	${MOSES_BIN}/consolidate \
	<(zcat -f $1.tmp/fwd.scored.gz) \
	<(${merge-sorted} $1.tmp/bwd/scored.*.gz) /dev/stdout \
	$$(if $$(smooth), $$(smooth) $1.tmp/fwd.coc) \
	| gzip > $$@_ && mv $$@_ $$@
	$$(unlock)

$1.tmp/fwd.scored.gz: | $(merge-sorted)
$1.tmp/fwd.scored.gz: | $${shardsdir}/extract.done
$1.tmp/fwd.scored.gz: | $${wlexdir}/${L2}-given-${L1}.lex.gz
	$$(lock)
	$(merge-sorted) $${shardsdir}/*.fwd.gz \
	| $(moses.score-phrases) ${MOSES_BIN}/score - $${wlexdir}/${L2}-given-${L1}.lex.gz \
	$${@D}/fwd $$(smooth) && mv $$@_ $$@
	$$(unlock)

$1.tmp/bwd/scoring.done: | $${shardsdir}/extract.done
$1.tmp/bwd/scoring.done: | $${wlexdir}/${L1}-given-${L2}.lex.gz
	$$(lock)
	$(merge-sorted) $${shardsdir}/*.bwd.gz \
	| ${moses.score-phrases} ${MOSES_BIN}/score - $${wlexdir}/${L1}-given-${L2}.lex.gz \
	$${@D}/scored $$(smooth) --Inverse && touch $$@
	$$(unlock)

$1.%.gz: $1.txt.gz
	$$(lock)
	zcat $1.txt.gz | ${filter-pt} -n $$* | gzip > $$@_ && mv $$@_ $$@
	$$(unlock)

endef 
# end of create_phrase_table
#################################################################################

#################################################################################
# $1: input factor(s)
# $2: output factor(s)
# $3: number of features
# $4: stem of phrase table 

define add_binary_phrase_table

$(if $(filter $4.txt.gz,${M4M_HISTORY}),,$(call create_phrase_table,$(strip $4)))

mystem   := $(strip $4)
ffname   := TranslationModel$(words ${PTABLE_ENTRIES})
MY_ENTRY := PhraseDictionaryBinary
MY_ENTRY += name=$$(ffname)
MY_ENTRY += num-features=$(strip $3)
MY_ENTRY += input-factor=$(strip $1)
MY_ENTRY += output-factor=$(strip $2)
MY_ENTRY += path=$(abspath $(strip $4))
$(if ${moses.ini_ttable-limit},MY_ENTRY += table-limit=${moses.ini_ttable-limit})
PTABLE_ENTRIES += $$(subst $$(space),;,$${MY_ENTRY})
PTABLES        += $(strip $4).binphr.idx

$(strip $4).binphr.idx: infactor=$1
$(strip $4).binphr.idx: outfactor=$2
$(strip $4).binphr.idx: nscores=$3

endef
#################################################################################
%.binphr.idx: %.txt.gz | ${MOSES_BIN}/processPhraseTable
	$(info MOSES_BIN=${MOSES_BIN})
	$(lock)
	zcat -f $*.txt.gz | ${MOSES_BIN}/processPhraseTable \
	-ttable $(infactor) $(outfactor) - -nscores $(nscores) -out $@.lock/$(notdir $*)
	mv $@.lock/$(notdir $*).* ${@D}
	$(unlock)

#################################################################################
# $1: input factor(s)
# $2: output factor(s)
# $3: number of features
# $4: stem of phrase table 

define add_text_phrase_table

$(if $(filter $4.txt.gz,${M4M_HISTORY}),,$(call create_phrase_table,$4))

ffname   := TranslationModel$(words ${PTABLE_ENTRIES})
MY_ENTRY := PhraseDictionaryMemory
MY_ENTRY += name=$$(ffname)
MY_ENTRY += num-features=$(strip $3)
MY_ENTRY += input-factor=$(strip $1)
MY_ENTRY += output-factor=$(strip $2)
MY_ENTRY += path=$(abspath $4).txt.gz
$(if ${moses.ini_ttable-limit},MY_ENTRY += table-limit=${moses.ini_ttable-limit})
PTABLE_ENTRIES += $$(subst $$(space),;,$${MY_ENTRY})
PTABLES        += $(strip $4).txt.gz

endef
#################################################################################

# make sure we have all the tools
REQUIRED_TOOLS ?=
REQUIRED_TOOLS += ${merge-sorted}
REQUIRED_TOOLS += ${MOSES_BIN}/consolidate
REQUIRED_TOOLS += ${MOSES_BIN}/processPhraseTable
${REQUIRED_TOOLS}:
	$(error $@ not found)

